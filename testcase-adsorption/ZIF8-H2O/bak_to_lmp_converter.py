#!/usr/bin/env python
# coding: utf-8

import numpy as np

def read_mass_table(filename):
    mass_dict = {}
    with open(filename, 'r') as f:
        for line in f:
            parts = line.split()
            if len(parts) >= 2:
                name = parts[0]
                try:
                    mass = float(parts[1])
                    mass_dict[name] = mass
                except ValueError:
                    continue  # Skip lines with '*******' or invalid data
    return mass_dict

def read_bak(filename):

    with open(filename, 'r') as f:
        lines = f.readlines()

    data = {}
    line_cpt = 0

    # 1. Number of species types
    num_species_types = int(lines[line_cpt].strip())
    data['num_species_types'] = num_species_types
    line_cpt += 1

    # 2. Species definitions (species ID, #atoms, active?, mu)
    species_list = []
    for i in range(num_species_types):
        parts = lines[line_cpt].split()

        species = {
            'number_residue': np.int32(parts[0]),
            'atom_per_residue': np.int32(parts[1]),
            'active': bool(np.int32(parts[2])),
            'mu': float(parts[3])  # assuming 4th value is chemical potential
        }
        species_list.append(species)
        line_cpt += 1

    # 3. Species names and charges
    species_names = []
    charges = []
    while line_cpt < len(lines):
        line = lines[line_cpt].strip()
        if line == "":
            line_cpt += 1
            continue
        parts = line.split()
        if len(parts) == 2:
            species_names.append(parts[0])
            charges.append(float(parts[1]))
            line_cpt += 1
        else:
            break  # end of this section
    data['species_names'] = species_names
    data['charges'] = charges

    # 4. Coordinates parsing
    coordinates = []
    atom_types = []
    atom_names = []
    counter_resname = 0
    for i, spec in enumerate(species_list):

        atom_per_residue = spec['atom_per_residue']
        number_residue = spec['number_residue']
        for j in range(number_residue):
            id_atom = i
            com = np.array(list(map(float, lines[line_cpt].split())))
            line_cpt += 1
            if atom_per_residue == 1:
                coordinates.append(com)
                atom_types.append(id_atom)
                atom_names.append(species_names[counter_resname])
            else:
                for _ in range(atom_per_residue):
                    id_atom += 1
                    rel = np.array(list(map(float, lines[line_cpt].split())))
                    abs_pos = com + rel
                    coordinates.append(abs_pos)
                    line_cpt += 1
                    atom_types.append(id_atom)
                    atom_names.append(species_names[counter_resname+id_atom-1])

        counter_resname += atom_per_residue

    data['coordinates'] = coordinates
    data['atom_types'] = atom_types
    data['atom_names'] = atom_names

    assert len(coordinates) == len(atom_types)

    # 5. Read box matrix (3 lines Ã— 3 columns)
    box = []
    for _ in range(3):
        parts = lines[line_cpt].split()
        vec = list(map(float, parts))
        box.append(vec)
        line_cpt += 1

    data['box'] = np.array(box)

    # 6. Skip 2 unused lines
    line_cpt += 2  # Just skip them

    return data

def write_lammps_data(filename, data, symmetrize = False):
    coords = data['coordinates']
    species_names = data['species_names']
    charges = data['charges']
    box = data['box']
    atom_names = data['atom_names']

    # Map unique species names to atom type IDs (1-based)
    unique_species = list(dict.fromkeys(species_names))  # preserve order
    species_to_typeid = {name: i + 1 for i, name in enumerate(unique_species)}

    with open(filename, 'w') as f:
        f.write("LAMMPS data file generated by bak-to-lmp-converted.py\n\n")

        num_atoms = len(coords)
        num_atom_types = len(unique_species)

        f.write(f"{num_atoms} atoms\n")
        f.write(f"{num_atom_types} atom types\n\n")

        # Box bounds
        if symmetrize:
            xlo, xhi = -box[0][0]/2, box[0][0]/2
            ylo, yhi = -box[1][1]/2, box[1][1]/2
            zlo, zhi = -box[2][2]/2, box[2][2]/2
        else:
            xlo, xhi = 0.0, box[0][0]
            ylo, yhi = 0.0, box[1][1]
            zlo, zhi = 0.0, box[2][2]
        f.write(f"{xlo:.6f} {xhi:.6f} xlo xhi\n")
        f.write(f"{ylo:.6f} {yhi:.6f} ylo yhi\n")
        f.write(f"{zlo:.6f} {zhi:.6f} zlo zhi\n\n")

        masses = read_mass_table("zif8-water.masses")

        # Masses (use dummy mass = 1.0 unless you have real masses)
        f.write("Masses\n\n")
        for i, name in enumerate(unique_species, 1):
            f.write(f"{i} {masses[name]} # {name}\n")
        f.write("\n")

        # Atoms section (atom ID, molecule-ID, atom-type, charge, x, y, z)
        f.write("Atoms # full\n\n")
        for i, (pos, name) in enumerate(zip(coords, atom_names), 1):
            type_id = species_to_typeid[name]
            charge = charges[species_names.index(name)]
            f.write(f"{i} 1 {type_id} {charge:.6f} {pos[0]:.8f} {pos[1]:.8f} {pos[2]:.8f}\n")

def read_bacben(filename):

        interactions = {}

        with open(filename, 'r') as f:
            lines = f.readlines()

        line_cpt = 0

        # Skip header and zero block
        while line_cpt < len(lines):

            # Skip and the zeros
            while line_cpt < bak_data["num_species_types"] + 3 + 1:
                line_cpt += 1

            # Now in LJ interaction block
            while line_cpt < len(lines):
                line = lines[line_cpt].strip()

                # Skip line in "*************"
                if not line or line.startswith('*'):
                    line_cpt += 1
                    continue

                parts = line.split()
                if len(parts) != 3:
                    line_cpt += 1
                    print(line_cpt, "WARNING: malformed line:", line)
                    continue  # skip malformed

                id, atom1, atom2 = parts
                line_cpt += 1

                sigma_eps_line = lines[line_cpt].strip()
                line_cpt += 1

                key = tuple(sorted((atom1, atom2)))

                if id == "2":
                    sigma, epsilon = map(float, sigma_eps_line.split())
                    interactions[key] = {"sigma": sigma, "epsilon": epsilon}
                else:
                    interactions[key] = {"sigma": 0, "epsilon": 0}

        return interactions

def write_lammps_pair_coeff(filename, parameters, data):
    species_names = list(dict.fromkeys(data["species_names"]))

    with open(filename, 'w') as f:
        f.write("# LAMMPS Lennard-Jones pair coefficients\n")
        f.write("# epsilon (kcal/mol), sigma (Angstrom)\n\n")

        type1 = 1
        for name1 in species_names:
            type2 = 1
            for name2 in species_names:
                if type1 <= type2:


                    key = tuple((name1, name2))
                    param = parameters.get(key, None)
                    if param is None:
                        key = tuple((name2, name1))
                        param = parameters.get(key, None)

                    kB = 0.0019872041 # kcal/mol/K
                    sigma = param['sigma']
                    epsilon_K = param['epsilon']
                    epsilon_kcal = epsilon_K * kB

                    f.write(f"pair_coeff {type1} {type2} {epsilon_kcal:.6f} {sigma:.6f}  # {name1}-{name2}\n")

                type2 += 1
            type1 += 1

filename = "zif8-water.bak"
bak_data = read_bak(filename)

filename = "zif8-water.data"
write_lammps_data(filename, bak_data, symmetrize=True)

filename = "zif8-water.pacben"
bacben_parameters = read_bacben(filename)

filename = "zif8-water.inc"
write_lammps_pair_coeff(filename, bacben_parameters, bak_data)

